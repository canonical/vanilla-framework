#! /usr/bin/env bash

# CAUTION:
# This file should usually not be edited directly.
#
# This file was generated by the "canonical-webteam" Yeoman generator
# https://npmjs.org/package/generator-canonical-webteam
#
# Update it to the latest version with:
#
# $ sudo npm install -g yo generator-canonical-webteam
# $ yo canonical-webteam:run

set -euo pipefail

# Define the versions of the two docker images
bundler_image="canonicalwebteam/bundler:v0.1.2"
node_image="canonicalwebteam/node:v0.1.0"

USAGE="Usage
===

  $ ./run \\
    [-m|--node-module PATH]  # A path to a local node module to use instead of the installed dependencies \\
    [COMMAND]                # Optionally provide a command to run

If no COMMAND is provided, \`serve\` will be run.

Commands
---

- serve [-p|--port PORT] [-w|--watch] [-d|--detach]: Run \`yarn run serve\` (optionally running \`watch\` in the background)
- watch [-s|--watch-site]: Run \`yarn run watch\` (optionally watching for jekyll changes in the background)
- build: Run \`yarn run build\`
- test: Run \`yarn run test\`
- stop: Stop any running containers
- node <args>: Run a command in the node container
- clean: Remove all images and containers, any installed dependencies and the .docker-project file
- clean-cache: Empty cache files, which are saved between projects (eg, yarn)
"

##
# Check docker is installed correctly
##
if ! command -v docker >/dev/null 2>&1; then
    echo "
    Error: Docker not installed
    ==
    Please install Docker before continuing:
    https://www.docker.com/products/docker
    "
    exit 1
fi
if grep -q '^docker:' /etc/group && ! groups | grep -q '\bdocker\b'; then
    echo "
    Error: `whoami` not in docker group
    ===
    Please add this user to the docker group, e.g. with:
    \$ newgrp docker
    "
    exit 1
fi

# Generate the project name
if [[ -f ".docker-project" ]]; then
    project=$(cat .docker-project)
else
    directory=$(basename `pwd`)
    hash=$((pwd | md5sum 2> /dev/null || md5 -q -s `pwd`) | cut -c1-8)
    project=canonical-webteam-${directory}-${hash}
    echo $project > .docker-project
fi

# Settings
module_volumes=()
node_cache_volume="${CANONICAL_WEBTEAM_NODE_CACHE_VOLUME:-canonical-webteam-node-cache}"
[ -t 1 ] && tty="--tty --interactive" || tty=""           # Do we have a terminal?
[ -f .env ] && env_file="--env-file .env" || env_file=""  # Do we have an env file?


# Defaults environment settings
PORT=8000

# Import environment settings
if [ -f .env ]; then
    export $(cat .env | grep -v ^\# | xargs)
fi

invalid() {
    message=${1}
    echo "Error: ${message}"
    echo ""
    echo "$USAGE"
    exit 1
}

# Read optional arguments
while [[ -n "${1:-}" ]] && [[ "${1:0:1}" == "-" ]]; do
    key="$1"

    case $key in

        -m|--node-module)
            if [ -z "${2:-}" ]; then invalid "Missing module name. Usage: --node-module <path-to-module>."; fi
            module_volumes+=("--volume" "${2}":"`pwd`/node_modules/$(basename ${2})")
            shift
        ;;
        -h|--help) echo "$USAGE"; exit ;;
        *) invalid "Option '${key}' not recognised." ;;
    esac
    shift
done

kill_container () {
    container_name="${1}"

    # Kill any previous containers
    previous_id=$(docker ps --all --quiet --filter "name=^/${container_name}$")
    if [ -n "${previous_id}" ]; then
        docker rm --force ${previous_id} > /dev/null;
    fi
}

run_as_user () {
    # Run a container as the current user and in the current directory context

    # Get options
    container_name=${1}; shift  # Get container_name as first argument

    # Kill existing containers
    kill_container "${container_name}"

    # Start the new container
    docker run  \
        --name ${container_name}  `# Name the container` \
        --rm                      `# Remove the container once it's finished`  \
        --user $(id -u):$(id -g)  `# Use the current user inside container`  \
        ${env_file}               `# Pass environment variables into the container, if file exists`  \
        --volume `pwd`:`pwd`      `# Mirror current directory inside container`  \
        --workdir `pwd`           `# Set current directory to the image's work directory`  \
        ${tty}                    `# Attach a pseudo-terminal, if relevant`  \
        $@                        `# Extra arguments`
}


bundler_run () {
    container_name="${1}"
    command="${2:-}"
    extra_options="${3:-}"

    # Kill existing containers
    kill_container "${container_name}"

    docker run \
        --name ${container_name}             `# Name the container` \
        --rm                                 `# Remove the container once it's finished`  \
        ${env_file}                          `# Pass environment variables into the container, if file exists`  \
        --tty --interactive                  `# Attach an interactive terminal`  \
        --user $(id -u):$(id -g)             `# Run everything as the current user`  \
        --volume `pwd`:`pwd` --workdir `pwd` `# Run in the current working directory`  \
        --volume ${project}-bundle:/bundler  `# Persist ruby dependencies in a docker volume`  \
        ${extra_options}                     `# Extra options`  \
        ${bundler_image} ${command}          `# Run the jeklyll command`
}


node_run () {
    # Standard options for running node commands
    container_name="${1}"
    command="${2:-}"
    extra_options="${3:-}"

    # Run a command in the "node" image
    run_as_user "${container_name}"  \
        --volume ${node_cache_volume}:/home/shared/.cache/  `# Bind cache to volume` \
        ${module_volumes[@]+"${module_volumes[@]}"}  `# Add any override modules as volumes`  \
        ${extra_options}                             `# Extra options`  \
        ${node_image} ${command}                     `# Run command in node image`
}

node_install () {
    # Install bower dependencies, if we need to
    if [ -f "bower.json" ]; then
        node_run "${project}-bower-install" "bower install"
    fi

    # Install yarn dependencies, without module overrides
    run_as_user "${project}-yarn-install" \
        --volume ${node_cache_volume}:/home/shared/.cache/  `# Bind yarn cache to volume` \
        ${node_image} yarn install  `# Install yarn dependencies`
}



# Find current run command
run_command=${1:-}
if [[ -n "${run_command}" ]]; then shift; fi

# Do the real business
case $run_command in
    ""|"serve")
        node_install

        # Read optional arguments
        detach=""
        run_watcher=false
        while [[ -n "${1:-}" ]] && [[ "${1:0:1}" == "-" ]]; do
            key="$1"

            case $key in
                -d|--detach) detach="--detach" ;;
                -p|--port)
                    if [ -z "${2:-}" ]; then invalid "Missing port number. Usage: --port XXXX"; fi
                    PORT=${2}
                    shift
                ;;
                -w|--watch) run_watcher=true ;;
                *) invalid "Option '${key}' not recognised." ;;
            esac
            shift
        done

        node_run "${project}-build" "yarn run build"

        # Run watch command in the background
        if ${run_watcher}; then
            if [ -z "${detach}" ];  then trap "kill_container ${project}-watch" EXIT; fi
            node_run "${project}-watch" "yarn run watch" "--detach"  # Run watch in the background
        fi

        

        # Run the serve container, publishing the port, and detaching if required
        bundler_run "${project}-serve" "jekyll serve -P ${PORT} -H 0.0.0.0" "--env PORT=${PORT} --publish ${PORT}:${PORT} ${detach}"
        
    ;;
    "stop")
        echo "Stopping all running containers for ${project}"
        running_containers="$(docker ps --quiet --filter name=${project})"
        docker kill ${running_containers}
    ;;
    "watch")
        
        # Read optional arguments
        watch_site=false
        while [[ -n "${1:-}" ]] && [[ "${1:0:1}" == "-" ]]; do
            key="$1"

            case $key in
                -s|--watch-site) watch_site=true ;;
                *) invalid "Option '${key}' not recognised." ;;
            esac
            shift
        done
        if ${watch_site}; then
            trap "kill_container ${project}-watch-site" EXIT
            bundler_run "${project}-watch-site" "jekyll build --watch" "--detach"  # Run site watcher in the background
        fi
        
        node_install
        node_run "${project}-build" "yarn run build"
        node_run "${project}-watch" "yarn run watch"
    ;;
    "build")
        node_install
        node_run "${project}-build" "yarn run build"
        bundler_run "${project}-build-site" "jekyll build"
    ;;
    "test")
        node_install
        node_run "${project}-yarn-test" "yarn run test"
        
    ;;
    "clean")
        echo "Running 'clean' yarn script"
        node_run "${project}-clean" "yarn run clean" || true  # Run the clean script

        echo "Removing all containers, volumes and networks for project: ${project}"
        project_containers="$(docker ps --all --quiet --filter name=${project})"
        project_volumes="$(docker volume ls --quiet --filter name=${project})"
        project_networks="$(docker network ls --quiet --filter name=${project})"
        if [ -n "${project_containers}" ]; then docker rm --force ${project_containers}; fi
        if [ -n "${project_volumes}" ]; then docker volume rm --force ${project_volumes}; fi
        if [ -n "${project_networks}" ]; then docker network rm ${project_networks}; fi

        echo "Removing .docker-project file"
        rm -rf .docker-project  # Remove the project file
    ;;
    "clean-cache")
        # Clean node cache volume
        echo "Removing cache volume ${node_cache_volume}"
        containers_using_volume=$(docker ps --quiet --all --filter "volume=${node_cache_volume}")
        if [ -n "${containers_using_volume}" ]; then docker rm --force ${containers_using_volume}; fi
        docker volume rm --force ${node_cache_volume}
    ;;
    "node") node_run "${project}-node-$(date +'%s')" "${@}" ;;
    *) invalid "Command '${run_command}' not recognised." ;;
esac
